<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>OVS-on-Hyper-V Design &mdash; Open vSwitch 2.6.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '2.6.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Open vSwitch 2.6.0 documentation" href="../index.html" />
    <link rel="up" title="Open vSwitch Deep Dive" href="index.html" />
    <link rel="next" title="Language Bindings" href="language-bindings.html" />
    <link rel="prev" title="DPDK vHost User Ports" href="dpdk/vhost-user.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="language-bindings.html" title="Language Bindings"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dpdk/vhost-user.html" title="DPDK vHost User Ports"
             accesskey="P">previous</a> |</li>
        <li><a href="../contents.html">Open vSwitch 2.6.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Open vSwitch Deep Dive</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="ovs-on-hyper-v-design">
<h1>OVS-on-Hyper-V Design<a class="headerlink" href="#ovs-on-hyper-v-design" title="Permalink to this headline">¶</a></h1>
<p>This document provides details of the effort to develop Open vSwitch on
Microsoft Hyper-V. This document should give enough information to understand
the overall design.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The userspace portion of the OVS has been ported to Hyper-V in a separate
effort, and committed to the openvswitch repo. This document will mostly
emphasize on the kernel driver, though we touch upon some of the aspects of
userspace as well.</p>
</div>
<div class="section" id="background-info">
<h2>Background Info<a class="headerlink" href="#background-info" title="Permalink to this headline">¶</a></h2>
<p>Microsoft’s hypervisor solution - Hyper-V <a class="footnote-reference" href="#id12" id="id1">[1]</a> implements a virtual switch
that is extensible and provides opportunities for other vendors to implement
functional extensions <a class="footnote-reference" href="#id13" id="id2">[2]</a>. The extensions need to be implemented as NDIS
drivers that bind within the extensible switch driver stack provided. The
extensions can broadly provide the functionality of monitoring, modifying and
forwarding packets to destination ports on the Hyper-V extensible switch.
Correspondingly, the extensions can be categorized into the following types and
provide the functionality noted:</p>
<ul class="simple">
<li>Capturing extensions: monitoring packets</li>
<li>Filtering extensions: monitoring, modifying packets</li>
<li>Forwarding extensions: monitoring, modifying, forwarding packets</li>
</ul>
<p>As can be expected, the kernel portion (datapath) of OVS on Hyper-V solution
will be implemented as a forwarding extension.</p>
<p>In Hyper-V, the virtual machine is called the Child Partition. Each VIF or
physical NIC on the Hyper-V extensible switch is attached via a port. Each port
is both on the ingress path or the egress path of the switch. The ingress path
is used for packets being sent out of a port, and egress is used for packet
being received on a port. By design, NDIS provides a layered interface. In this
layered interface, higher level layers call into lower level layers, in the
ingress path. In the egress path, it is the other way round. In addition, there
is a object identifier (OID) interface for control operations Eg. addition of a
port. The workflow for the calls is similar in nature to the packets, where
higher level layers call into the lower level layers. A good representational
diagram of this architecture is in <a class="footnote-reference" href="#id15" id="id3">[4]</a>.</p>
<p>Windows Filtering Platform (WFP) <a class="footnote-reference" href="#id16" id="id4">[5]</a> is a platform implemented on Hyper-V that
provides APIs and services for filtering packets. WFP has been utilized to
filter on some of the packets that OVS is not equipped to handle directly. More
details in later sections.</p>
<p>IP Helper <a class="footnote-reference" href="#id17" id="id5">[6]</a> is a set of API available on Hyper-V to retrieve information
related to the network configuration information on the host machine. IP Helper
has been used to retrieve some of the configuration information that OVS needs.</p>
</div>
<div class="section" id="design">
<h2>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre>Various blocks of the OVS Windows implementation

                                  +-------------------------------+
                                  |                               |
                                  |        CHILD PARTITION        |
                                  |                               |
  +------+ +--------------+       | +-----------+  +------------+ |
  |      | |              |       | |           |  |            | |
  | ovs- | |     OVS-     |       | | Virtual   |  | Virtual    | |
  | *ctl | |  USERSPACE   |       | | Machine #1|  | Machine #2 | |
  |      | |    DAEMON    |       | |           |  |            | |
  +------+-++---+---------+       | +--+------+-+  +----+------++ | +--------+
  |  dpif-  |   | netdev- |       |    |VIF #1|         |VIF #2|  | |Physical|
  | netlink |   | windows |       |    +------+         +------+  | |  NIC   |
  +---------+   +---------+       |      ||                   /\  | +--------+
User     /\         /\            |      || *#1*         *#4* ||  |     /\
=========||=========||============+------||-------------------||--+     ||
Kernel   ||         ||                   \/                   ||  ||=====/
         \/         \/                +-----+                 +-----+ *#5*
 +-------------------------------+    |     |                 |     |
 |   +----------------------+    |    |     |                 |     |
 |   |   OVS Pseudo Device  |    |    |     |                 |     |
 |   +----------------------+    |    |     |                 |     |
 |      | Netlink Impl. |        |    |     |                 |     |
 |      -----------------        |    |  I  |                 |     |
 | +------------+                |    |  N  |                 |  E  |
 | |  Flowtable | +------------+ |    |  G  |                 |  G  |
 | +------------+ |  Packet    | |*#2*|  R  |                 |  R  |
 |   +--------+   | Processing | |&lt;=&gt; |  E  |                 |  E  |
 |   |   WFP  |   |            | |    |  S  |                 |  S  |
 |   | Driver |   +------------+ |    |  S  |                 |  S  |
 |   +--------+                  |    |     |                 |     |
 |                               |    |     |                 |     |
 |   OVS FORWARDING EXTENSION    |    |     |                 |     |
 +-------------------------------+    +-----+-----------------+-----+
                                      |HYPER-V Extensible Switch *#3|
                                      +-----------------------------+
                                               NDIS STACK
</pre></div>
</div>
<p>This diagram shows the various blocks involved in the OVS Windows
implementation, along with some of the components available in the NDIS stack,
and also the virtual machines. The workflow of a packet being transmitted from
a VIF out and into another VIF and to a physical NIC is also shown. Later on in
this section, we will discuss the flow of a packet at a high level.</p>
<p>The figure gives a general idea of where the OVS userspace and the kernel
components fit in, and how they interface with each other.</p>
<p>The kernel portion (datapath) of OVS on Hyper-V solution has be implemented as
a forwarding extension roughly implementing the following
sub-modules/functionality. Details of each of these sub-components in the
kernel are contained in later sections:</p>
<ul class="simple">
<li>Interfacing with the NDIS stack</li>
<li>Netlink message parser</li>
<li>Netlink sockets</li>
<li>Switch/Datapath management</li>
<li>Interfacing with userspace portion of the OVS solution to implement the
necessary functionality that userspace needs</li>
<li>Port management</li>
<li>Flowtable/Actions/packet forwarding</li>
<li>Tunneling</li>
<li>Event notifications</li>
</ul>
<p>The datapath for the OVS on Linux is a kernel module, and cannot be directly
ported since there are significant differences in architecture even though the
end functionality provided would be similar. Some examples of the differences
are:</p>
<ul class="simple">
<li>Interfacing with the NDIS stack to hook into the NDIS callbacks for
functionality such as receiving and sending packets, packet completions, OIDs
used for events such as a new port appearing on the virtual switch.</li>
<li>Interface between the userspace and the kernel module.</li>
<li>Event notifications are significantly different.</li>
<li>The communication interface between DPIF and the kernel module need not be
implemented in the way OVS on Linux does. That said, it would be advantageous
to have a similar interface to the kernel module for reasons of readability
and maintainability.</li>
<li>Any licensing issues of using Linux kernel code directly.</li>
</ul>
<p>Due to these differences, it was a straightforward decision to develop the
datapath for OVS on Hyper-V from scratch rather than porting the one on Linux.
A re-development focused on the following goals:</p>
<ul class="simple">
<li>Adhere to the existing requirements of userspace portion of OVS (such as
ovs-vswitchd), to minimize changes in the userspace workflow.</li>
<li>Fit well into the typical workflow of a Hyper-V extensible switch forwarding
extension.</li>
</ul>
<p>The userspace portion of the OVS solution is mostly POSIX code, and not very
Linux specific. Majority of the userspace code does not interface directly with
the kernel datapath and was ported independently of the kernel datapath effort.</p>
<p>As explained in the OVS porting design document <a class="footnote-reference" href="#id18" id="id6">[7]</a>, DPIF is the portion of
userspace that interfaces with the kernel portion of the OVS. The interface
that each DPIF provider has to implement is defined in <tt class="docutils literal"><span class="pre">dpif-provider.h</span></tt>
<a class="footnote-reference" href="#id14" id="id7">[3]</a>.  Though each platform is allowed to have its own implementation of the
DPIF provider, it was found, via community feedback, that it is desired to
share code whenever possible. Thus, the DPIF provider for OVS on Hyper-V shares
code with the DPIF provider on Linux. This interface is implemented in
<tt class="docutils literal"><span class="pre">dpif-netlink.c</span></tt>.</p>
<p>We&#8217;ll elaborate more on kernel-userspace interface in a dedicated section
below. Here it suffices to say that the DPIF provider implementation for
Windows is netlink-based and shares code with the Linux one.</p>
</div>
<div class="section" id="kernel-module-datapath">
<h2>Kernel Module (Datapath)<a class="headerlink" href="#kernel-module-datapath" title="Permalink to this headline">¶</a></h2>
<div class="section" id="interfacing-with-the-ndis-stack">
<h3>Interfacing with the NDIS Stack<a class="headerlink" href="#interfacing-with-the-ndis-stack" title="Permalink to this headline">¶</a></h3>
<p>For each virtual switch on Hyper-V, the OVS extensible switch extension can be
enabled/disabled. We support enabling the OVS extension on only one switch.
This is consistent with using a single datapath in the kernel on Linux. All the
physical adapters are connected as external adapters to the extensible switch.</p>
<p>When the OVS switch extension registers itself as a filter driver, it also
registers callbacks for the switch/port management and datapath functions. In
other words, when a switch is created on the Hyper-V root partition (host), the
extension gets an activate callback upon which it can initialize the data
structures necessary for OVS to function. Similarly, there are callbacks for
when a port gets added to the Hyper-V switch, and an External Network adapter
or a VM Network adapter is connected/disconnected to the port. There are also
callbacks for when a VIF (NIC of a child partition) send out a packet, or a
packet is received on an external NIC.</p>
<p>As shown in the figures, an extensible switch extension gets to see a packet
sent by the VM (VIF) twice - once on the ingress path and once on the egress
path. Forwarding decisions are to be made on the ingress path. Correspondingly,
we will be hooking onto the following interfaces:</p>
<ul class="simple">
<li>Ingress send indication: intercept packets for performing flow based
forwarding.This includes straight forwarding to output ports. Any packet
modifications needed to be performed are done here either inline or by
creating a new packet. A forwarding action is performed as the flow actions
dictate.</li>
<li>Ingress completion indication: cleanup and free packets that we generated on
the ingress send path, pass-through for packets that we did not generate.</li>
<li>Egress receive indication: pass-through.</li>
<li>Egress completion indication: pass-through.</li>
</ul>
</div>
<div class="section" id="interfacing-with-ovs-userspace">
<h3>Interfacing with OVS Userspace<a class="headerlink" href="#interfacing-with-ovs-userspace" title="Permalink to this headline">¶</a></h3>
<p>We have implemented a pseudo device interface for letting OVS userspace talk to
the OVS kernel module. This is equivalent to the typical character device
interface on POSIX platforms where we can register custom functions for read,
write and ioctl functionality. The pseudo device supports a whole bunch of
ioctls that netdev and DPIF on OVS userspace make use of.</p>
</div>
<div class="section" id="netlink-message-parser">
<h3>Netlink Message Parser<a class="headerlink" href="#netlink-message-parser" title="Permalink to this headline">¶</a></h3>
<p>The communication between OVS userspace and OVS kernel datapath is in the form
of Netlink messages <a class="footnote-reference" href="#id12" id="id8">[1]</a>, <a class="footnote-reference" href="#id19" id="id9">[8]</a>. More details about this are provided below.  In the
kernel, a full fledged netlink message parser has been implemented along the
lines of the netlink message parser in OVS userspace. In fact, a lot of the
code is ported code.</p>
<p>On the lines of <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">ofpbuf</span></tt> in OVS userspace, a managed buffer has been
implemented in the kernel datapath to make it easier to parse and construct
netlink messages.</p>
</div>
<div class="section" id="netlink-sockets">
<h3>Netlink Sockets<a class="headerlink" href="#netlink-sockets" title="Permalink to this headline">¶</a></h3>
<p>On Linux, OVS userspace utilizes netlink sockets to pass back and forth netlink
messages. Since much of userspace code including DPIF provider in
dpif-netlink.c (formerly dpif-linux.c) has been reused, pseudo-netlink sockets
have been implemented in OVS userspace. As it is known, Windows lacks native
netlink socket support, and also the socket family is not extensible either.
Hence it is not possible to provide a native implementation of netlink socket.
We emulate netlink sockets in lib/netlink-socket.c and support all of the nl_*
APIs to higher levels. The implementation opens a handle to the pseudo device
for each netlink socket. Some more details on this topic are provided in the
userspace section on netlink sockets.</p>
<p>Typical netlink semantics of read message, write message, dump, and transaction
have been implemented so that higher level layers are not affected by the
netlink implementation not being native.</p>
</div>
<div class="section" id="switch-datapath-management">
<h3>Switch/Datapath Management<a class="headerlink" href="#switch-datapath-management" title="Permalink to this headline">¶</a></h3>
<p>As explained above, we hook onto the management callback functions in the NDIS
interface for when to initialize the OVS data structures, flow tables etc. Some
of this code is also driven by OVS userspace code which sends down ioctls for
operations like creating a tunnel port etc.</p>
</div>
<div class="section" id="port-management">
<h3>Port Management<a class="headerlink" href="#port-management" title="Permalink to this headline">¶</a></h3>
<p>As explained above, we hook onto the management callback functions in the NDIS
interface to know when a port is added/connected to the Hyper-V switch. We use
these callbacks to initialize the port related data structures in OVS. Also,
some of the ports are tunnel ports that don’t exist on the Hyper-V switch and
get added from OVS userspace.</p>
<p>In order to identify a Hyper-V port, we use the value of &#8216;FriendlyName&#8217; field
in each Hyper-V port. We call this the &#8220;OVS-port-name&#8221;. The idea is that OVS
userspace sets &#8216;OVS-port-name&#8217; in each Hyper-V port to the same value as the
&#8216;name&#8217; field of the &#8216;Interface&#8217; table in OVSDB. When OVS userspace calls into
the kernel datapath to add a port, we match the name of the port with the
&#8216;OVS-port-name&#8217; of a Hyper-V port.</p>
<p>We maintain separate hash tables, and separate counters for ports that have
been added from the Hyper-V switch, and for ports that have been added from OVS
userspace.</p>
</div>
<div class="section" id="flowtable-actions-packet-forwarding">
<h3>Flowtable/Actions/Packet Forwarding<a class="headerlink" href="#flowtable-actions-packet-forwarding" title="Permalink to this headline">¶</a></h3>
<p>The flowtable and flow actions based packet forwarding is the core of the OVS
datapath functionality. For each packet on the ingress path, we consult the
flowtable and execute the corresponding actions. The actions can be limited to
simple forwarding to a particular destination port(s), or more commonly
involves modifying the packet to insert a tunnel context or a VLAN ID, and
thereafter forwarding to the external port to send the packet to a destination
host.</p>
</div>
<div class="section" id="tunneling">
<h3>Tunneling<a class="headerlink" href="#tunneling" title="Permalink to this headline">¶</a></h3>
<p>We make use of the Internal Port on a Hyper-V switch for implementing
tunneling. The Internal Port is a virtual adapter that is exposed on the Hyper-
V host, and connected to the Hyper-V switch. Basically, it is an interface
between the host and the virtual switch. The Internal Port acts as the Tunnel
end point for the host (aka VTEP), and holds the VTEP IP address.</p>
<p>Tunneling ports are not actual ports on the Hyper-V switch. These are virtual
ports that OVS maintains and while executing actions, if the outport is a
tunnel port, we short circuit by performing the encapsulation action based on
the tunnel context. The encapsulated packet gets forwarded to the external
port, and appears to the outside world as though it was set from the VTEP.</p>
<p>Similarly, when a tunneled packet enters the OVS from the external port bound
to the internal port (VTEP), and if yes, we short circuit the path, and
directly forward the inner packet to the destination port (mostly a VIF, but
dictated by the flow). We leverage the Windows Filtering Platform (WFP)
framework to be able to receive tunneled packets that cannot be decapsulated by
OVS right away. Currently, fragmented IP packets fall into that category, and
we leverage the code in the host IP stack to reassemble the packet, and
performing decapsulation on the reassembled packet.</p>
<p>We&#8217;ll also be using the IP helper library to provide us IP address and other
information corresponding to the Internal port.</p>
</div>
<div class="section" id="event-notifications">
<h3>Event Notifications<a class="headerlink" href="#event-notifications" title="Permalink to this headline">¶</a></h3>
<p>The pseudo device interface described above is also used for providing event
notifications back to OVS userspace. A shared memory/overlapped IO model is
used.</p>
</div>
<div class="section" id="userspace-components">
<h3>Userspace Components<a class="headerlink" href="#userspace-components" title="Permalink to this headline">¶</a></h3>
<p>The userspace portion of the OVS solution is mostly POSIX code, and not very
Linux specific. Majority of the userspace code does not interface directly with
the kernel datapath and was ported independently of the kernel datapath effort.</p>
<p>In this section, we cover the userspace components that interface with the
kernel datapath.</p>
<p>As explained earlier, OVS on Hyper-V shares the DPIF provider implementation
with Linux. The DPIF provider on Linux uses netlink sockets and netlink
messages. Netlink sockets and messages are extensively used on Linux to
exchange information between userspace and kernel. In order to satisfy these
dependencies, netlink socket (pseudo and non-native) and netlink messages are
implemented on Hyper-V.</p>
<p>The following are the major advantages of sharing DPIF provider code:</p>
<ol class="arabic">
<li><p class="first">Maintenance is simpler:</p>
<p>Any change made to the interface defined in dpif-provider.h need not be
propagated to multiple implementations. Also, developers familiar with the
Linux implementation of the DPIF provider can easily ramp on the Hyper-V
implementation as well.</p>
</li>
<li><p class="first">Netlink messages provides inherent advantages:</p>
<p>Netlink messages are known for their extensibility. Each message is
versioned, so the provided data structures offer a mechanism to perform
version checking and forward/backward compatibility with the kernel module.</p>
</li>
</ol>
</div>
<div class="section" id="id10">
<h3>Netlink Sockets<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>As explained in other sections, an emulation of netlink sockets has been
implemented in <tt class="docutils literal"><span class="pre">lib/netlink-socket.c</span></tt> for Windows. The implementation creates
a handle to the OVS pseudo device, and emulates netlink socket semantics of
receive message, send message, dump, and transact. Most of the <tt class="docutils literal"><span class="pre">nl_*</span></tt>
functions are supported.</p>
<p>The fact that the implementation is non-native manifests in various ways.  One
example is that PID for the netlink socket is not automatically assigned in
userspace when a handle is created to the OVS pseudo device. There&#8217;s an extra
command (defined in <tt class="docutils literal"><span class="pre">OvsDpInterfaceExt.h</span></tt>) that is used to grab the PID
generated in the kernel.</p>
</div>
<div class="section" id="dpif-provider">
<h3>DPIF Provider<a class="headerlink" href="#dpif-provider" title="Permalink to this headline">¶</a></h3>
<p>As has been mentioned in earlier sections, the netlink socket and netlink
message based DPIF provider on Linux has been ported to Windows.</p>
<p>Most of the code is common. Some divergence is in the code to receive packets.
The Linux implementation uses epoll() <a class="footnote-reference" href="#id20" id="id11">[9]</a> which is not natively supported on
Windows.</p>
</div>
<div class="section" id="netdev-windows">
<h3>netdev-windows<a class="headerlink" href="#netdev-windows" title="Permalink to this headline">¶</a></h3>
<p>We have a Windows implementation of the interface defined in
<tt class="docutils literal"><span class="pre">lib/netdev-provider.h</span></tt>. The implementation provides functionality to get
extended information about an interface. It is limited in functionality
compared to the Linux implementation of the netdev provider and cannot be used
to add any interfaces in the kernel such as a tap interface or to send/receive
packets. The netdev-windows implementation uses the datapath interface
extensions defined in <tt class="docutils literal"><span class="pre">datapath-windows/include/OvsDpInterfaceExt.h</span></tt>.</p>
</div>
<div class="section" id="powershell-extensions-to-set-ovs-port-name">
<h3>Powershell Extensions to Set <tt class="docutils literal"><span class="pre">OVS-port-name</span></tt><a class="headerlink" href="#powershell-extensions-to-set-ovs-port-name" title="Permalink to this headline">¶</a></h3>
<p>As explained in the section on &#8220;Port management&#8221;, each Hyper-V port has a
&#8216;FriendlyName&#8217; field, which we call as the &#8220;OVS-port-name&#8221; field. We have
implemented powershell command extensions to be able to set the &#8220;OVS-port-name&#8221;
of a Hyper-V port.</p>
</div>
</div>
<div class="section" id="kernel-userspace-interface">
<h2>Kernel-Userspace Interface<a class="headerlink" href="#kernel-userspace-interface" title="Permalink to this headline">¶</a></h2>
<div class="section" id="openvswitch-h-and-ovsdpinterfaceext-h">
<h3>openvswitch.h and OvsDpInterfaceExt.h<a class="headerlink" href="#openvswitch-h-and-ovsdpinterfaceext-h" title="Permalink to this headline">¶</a></h3>
<p>Since the DPIF provider is shared with Linux, the kernel datapath provides the
same interface as the Linux datapath. The interface is defined in
<tt class="docutils literal"><span class="pre">datapath/linux/compat/include/linux/openvswitch.h</span></tt>. Derivatives of this
interface file are created during OVS userspace compilation. The derivative for
the kernel datapath on Hyper-V is provided in
<tt class="docutils literal"><span class="pre">datapath-windows/include/OvsDpInterface.h</span></tt>.</p>
<p>That said, there are Windows specific extensions that are defined in the
interface file <tt class="docutils literal"><span class="pre">datapath-windows/include/OvsDpInterfaceExt.h</span></tt>.</p>
</div>
</div>
<div class="section" id="flow-of-a-packet">
<h2>Flow of a Packet<a class="headerlink" href="#flow-of-a-packet" title="Permalink to this headline">¶</a></h2>
<p>Figure 2 shows the numbered steps in which a packets gets sent out of a VIF and
is forwarded to another VIF or a physical NIC. As mentioned earlier, each VIF
is attached to the switch via a port, and each port is both on the ingress and
egress path of the switch, and depending on whether a packet is being
transmitted or received, one of the paths gets used. In the figure, each step n
is annotated as <tt class="docutils literal"><span class="pre">#n</span></tt></p>
<p>The steps are as follows:</p>
<ol class="arabic simple">
<li>When a packet is sent out of a VIF or an physical NIC or an internal port,
the packet is part of the ingress path.</li>
<li>The OVS kernel driver gets to intercept this packet.<ol class="loweralpha">
<li>OVS looks up the flows in the flowtable for this packet, and executes the
corresponding action.</li>
<li>If there is not action, the packet is sent up to OVS userspace to examine
the packet and figure out the actions.</li>
<li>Userspace executes the packet by specifying the actions, and might also
insert a flow for such a packet in the future.</li>
<li>The destination ports are added to the packet and sent down to the Hyper-
V switch.</li>
</ol>
</li>
<li>The Hyper-V forwards the packet to the destination ports specified in the
packet, and sends it out on the egress path.</li>
<li>The packet gets forwarded to the destination VIF.</li>
<li>It might also get forwarded to a physical NIC as well, if the physical NIC
has been added as a destination port by OVS.</li>
</ol>
</div>
<div class="section" id="build-deployment">
<h2>Build/Deployment<a class="headerlink" href="#build-deployment" title="Permalink to this headline">¶</a></h2>
<p>The userspace components added as part of OVS Windows implementation have been
integrated with autoconf, and can be built using the steps mentioned in the
BUILD.Windows file. Additional targets need to be specified to make.</p>
<p>The OVS kernel code is part of a Visual Studio 2013 solution, and is compiled
from the IDE. There are plans in the future to move this to a compilation mode
such that we can compile it without an IDE as well.</p>
<p>Once compiled, we have an install script that can be used to load the kernel
driver.</p>
</div>
<div class="section" id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> Hyper-V Extensible Switch <a class="reference external" href="https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch">https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Hyper-V Extensible Switch Extensions <a class="reference external" href="https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch-extensions">https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch-extensions</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>DPIF Provider <a class="reference external" href="http://openvswitch.sourcearchive.com/documentation/1.1.0-1/dpif-provider_8h_source.html">http://openvswitch.sourcearchive.com/documentation/1.1.0-1/dpif-provider_8h_source.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[4]</a></td><td>Hyper-V Extensible Switch Components <a class="reference external" href="https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch-components">https://msdn.microsoft.com/windows/hardware/drivers/network/hyper-v-extensible-switch-components</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[5]</a></td><td>Windows Filtering Platform <a class="reference external" href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa366510(v=vs.85).aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/aa366510(v=vs.85).aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td>IP Helper <a class="reference external" href="https://msdn.microsoft.com/windows/hardware/drivers/network/ip-helper">https://msdn.microsoft.com/windows/hardware/drivers/network/ip-helper</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[7]</a></td><td>How to Port Open vSwitch to New Software or Hardware <a class="reference internal" href="porting.html"><em>Porting Open vSwitch to New Software or Hardware</em></a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>Netlink <a class="reference external" href="https://en.wikipedia.org/wiki/Netlink">https://en.wikipedia.org/wiki/Netlink</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td>epoll <a class="reference external" href="https://en.wikipedia.org/wiki/Epoll">https://en.wikipedia.org/wiki/Epoll</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../contents.html">
              <img class="logo" src="../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../contents.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">OVS-on-Hyper-V Design</a><ul>
<li><a class="reference internal" href="#background-info">Background Info</a></li>
<li><a class="reference internal" href="#design">Design</a></li>
<li><a class="reference internal" href="#kernel-module-datapath">Kernel Module (Datapath)</a><ul>
<li><a class="reference internal" href="#interfacing-with-the-ndis-stack">Interfacing with the NDIS Stack</a></li>
<li><a class="reference internal" href="#interfacing-with-ovs-userspace">Interfacing with OVS Userspace</a></li>
<li><a class="reference internal" href="#netlink-message-parser">Netlink Message Parser</a></li>
<li><a class="reference internal" href="#netlink-sockets">Netlink Sockets</a></li>
<li><a class="reference internal" href="#switch-datapath-management">Switch/Datapath Management</a></li>
<li><a class="reference internal" href="#port-management">Port Management</a></li>
<li><a class="reference internal" href="#flowtable-actions-packet-forwarding">Flowtable/Actions/Packet Forwarding</a></li>
<li><a class="reference internal" href="#tunneling">Tunneling</a></li>
<li><a class="reference internal" href="#event-notifications">Event Notifications</a></li>
<li><a class="reference internal" href="#userspace-components">Userspace Components</a></li>
<li><a class="reference internal" href="#id10">Netlink Sockets</a></li>
<li><a class="reference internal" href="#dpif-provider">DPIF Provider</a></li>
<li><a class="reference internal" href="#netdev-windows">netdev-windows</a></li>
<li><a class="reference internal" href="#powershell-extensions-to-set-ovs-port-name">Powershell Extensions to Set <tt class="docutils literal"><span class="pre">OVS-port-name</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernel-userspace-interface">Kernel-Userspace Interface</a><ul>
<li><a class="reference internal" href="#openvswitch-h-and-ovsdpinterfaceext-h">openvswitch.h and OvsDpInterfaceExt.h</a></li>
</ul>
</li>
<li><a class="reference internal" href="#flow-of-a-packet">Flow of a Packet</a></li>
<li><a class="reference internal" href="#build-deployment">Build/Deployment</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="dpdk/vhost-user.html"
                        title="previous chapter">DPDK vHost User Ports</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="language-bindings.html"
                        title="next chapter">Language Bindings</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/topics/windows.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="language-bindings.html" title="Language Bindings"
             >next</a> |</li>
        <li class="right" >
          <a href="dpdk/vhost-user.html" title="DPDK vHost User Ports"
             >previous</a> |</li>
        <li><a href="../contents.html">Open vSwitch 2.6.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Open vSwitch Deep Dive</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2016, The Open vSwitch Development Community.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>